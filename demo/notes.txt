下载了软件msys64用于包管理，如果还有别的需要下载的，可以优先使用

D:\msys64\ucrt64\bin  添加到了PATH中

安装了完整的 Verilog 工具链

我们安装了 ctags（用于代码跳转）。

我们安装了 MSYS2（作为我们的“应用商店”）。

通过 MSYS2，我们安装了 iverilog（Verilog 仿真器）、verilator（Linter 和高速仿真器）、gtkwave（波形查看器） 和 gcc（C++ 编译器）。



1.0
我将阐述一下这个脉冲阵列的设计，你需要查看你刚才修改的代码是否能满足这个逻辑
我将使用i和j来表示PE阵列的行和列，我需要计算D=A*B+C的矩阵运算，同时记矩阵乘法A*B=E
对于第j列，待输入的元素来自于矩阵B的第j行，输入顺序是从B[j][WIDTH-1]至B[j][0],那么最终PE[i][j]将存储B[j][i]
如果将第0列的第一个元素(即B[0][WIDTH-1])输入时刻记为第0个time step
那么第j列的第一个元素需要从第j个time step开始输入，并且每个元素每个time step向下传递一个PE
请注意，这里需要注意的是，如果一个PE没有新的weight(来自矩阵B的元素)流入，那么这个PE的权重需要保持不变，直到有新的weight(来自矩阵B的元素)流入

对于第i行，待输入的元素来自于矩阵A的第i列，输入顺序是从A[i][0]至A[i][WIDTH-1]
而第i行的开始输入时刻为第(i+WIDTH-1)个time step,并且每个元素每个time step向右传递一个PE

第PE[i][j]将在第(i+j)个时刻接收到B[j][i]，在第(i+j+WIDTH-1)个时刻受到A[i][0]以及来自于上方pe的pe_psum_out，在进行一次乘积运算后与来自上方PE的pe_psum_out求和，再输出到下方的PE
在接受第一个数据之后又经历WIDTH-1个时刻之后，PE[WIDTH-1][j],将输出A[k][]B

请注意，这个数据流并不是输出固定，它更类似与权重固定，只不过A矩阵中的元素的矩阵B中所有元素都输入到PE阵列后才开始输入，而是满足我上面阐述的规则

经过这个PE阵列后，我在第j列最后一行得到的第一个总的乘积和将是E[]

如果需要加上矩阵C，那么在vpu部分应该输入一个转置后的矩阵C与PE输出的结果相加
最终累和输出的矩阵需要经过一次转置，才是最终结果



2.0
首先所有的输入输出的矩阵均行优先的存储方式，即从A[0][0]-->A[0][WIDTH-1]-->...
我将使用i和j来表示PE阵列的行和列，我需要计算D=A*B+C的矩阵运算，同时记矩阵乘法A*B=E，ABCDE将是大小一致的矩阵，C的矩阵加法将由VPU实现

对于第j列，待输入的元素来自于矩阵A的第j行，输入顺序是从A[j][WIDTH-1]至A[j][0],那么最终PE[i][j]weight将存储A[j][i]
如果将第0列的第一个元素(即A[0][WIDTH-1])输入时刻记为第0个time step
那么第j列的第一个元素需要从第j个time step开始输入，并且每个元素每个time step向下传递一个PE
这个矩阵A的每个元素输入都同时伴随pe_accept_w_in=1输入以及对应序号的输入即A元素的列数
pe_accept_w_in=1将跟着每个A元素向下传递，直到A元素的列数等于PE的ROW(i)，新输入的数据将存储在weight_reg_inactive,且pe_accept_w_in将不再继续传播

?这个过程将在矩阵A加载前运行

?而这个过程可以在上一次运算还没结束时同步执行（如果是方矩阵，是可以跟上一个运算的A输入同步，不是方阵需要再思考一下）

?不是方矩阵填0补全？

接下来我将阐述矩阵B的元素流入过程；pe_valid_in和pe_switch_in的控制；psum的传递过程
对于第i行，待输入的元素来自于矩阵B的第i行，输入顺序是从B[i][0]至B[i][WIDTH-1]
如果将第0列的第一个A元素(即A[0][WIDTH-1])输入时刻记为第0个time step
对于pe_switch_in，将在每一行的第一个输入的B元素前一个time step输入，即输入为B[][0]的前一个周期输入一个pe_switch_in=1，pe_valid_in=0，并且每个time step向右传递一个PE
即第i行的pe_switch_in=1将在第(i+WIDTH)个time step时刻输入
那么第i行的数据开始输入时刻为第(i+WIDTH+1)个time step,并且每个元素每个time step向右传递一个PE
同时pe_valid_in在第i行的输入和B的输入保持同步，即矩阵B的每个元素输入都同时伴随pe_valid_in=1输入，并且每个time step向右传递一个PE
所有B元素在输入时pe_switch_in=0，

psum将从上到下传递并累加，最终在j列的最低端输出E[j][]
那么对于第j列，其输出结果将是A[j][k]*B[k][]的和，即依次输出E[j][0]-->E[j][WIDTH-1],那每一列收到的都是矩阵E的第j行

然后在t=w+1时刻开始下一个矩阵乘法A的加载，即第一列A_2[0][WIDTH-1]开始输入
?在B[0][0]进入的那一个time step，将输入新的A矩阵存储在weight_reg_inactive



暂时不要编写代码，回答我以下问题
1.当input_buffer中的数据被加载过了之后需要清除，这个操作是不是漏掉了，将由谁来进行？需要修改哪些代码；对于output_buffer也是同理，如果输出出去了就应该被删除

2.对于你现在呈现的control_unit逻辑，没有充分利用我原本设计的流水线优势，我将与你阐述
t=0，输入A[0][WIDTH-1]进入PE[0][0]，往后的每个时刻都输入一个元素，从A[0][WIDTH-1]到A[0][0]，将在t=WIDTH-1时刻输入完成
那么t=j，输入A[j][WIDTH-1]进入PE[0][j]，往后的每个时刻都输入一个元素，从A[j][WIDTH-1]到A[j][0]，将在t=j+WIDTH-1时刻输入完成

t=WIDTH，于PE[0][0]pe_switch_in=1，pe_valid_in=0的信号；t=i+WIDTH，于PE[i][0]pe_switch_in=1，pe_valid_in=0的信号。进行权重切换

t=WIDTH+1，输入B[0][0]进入PE[0][0]，往后的每个时刻都输入一个元素，从B[0][0]至B[0][WIDTH-1]，将在t=WIDTH+1+WIDTH-1=2*WIDTH时刻输入完成；同时，应该输入第二组的A[0][WIDTH-1]进入PE[0][0],往后的每个时刻都输入一个元素,将在t=2*WIDTH时刻输入完成
那么t=i+WIDTH+1，输入B[i][0]进入PE[i][0],往后的每个时刻都输入一个元素，从B[i][0]至B[i][WIDTH-1]，将在t=i+WIDTH+1+WIDTH-1=i+2*WIDTH时刻输入完成；同时，应该输入第二组的A[j][WIDTH-1]进入PE[0][j],往后的每个时刻都输入一个元素,将在t=i+2*WIDTH时刻输入完成

往后同理，即无论A还是B的，对于方阵，在第一组A或B矩阵中某行数据输入完后（这个过程在第一个元素开始输入后将历时WIDTH时长，如t=0到t=WIDTH-1），等待一个周期，然后就可以输入下一组对应位置的数据
当然我刚才的描述是方阵，对于不是方阵的，为了简化控制逻辑，仍按照方阵处理，即第一组某行第一个元素开始输入后历时WIDTH时长，等待一个周期，再输入下一组对应位置的数据。

对于矩阵C，vpu_sys_data_in[j]，将在t=2*WIDTH+1+j接受到E[j][0]，每往后一个时刻都接受到一个数据，从E[j][0]到E[j][WIDTH-1]，将在t=2*WIDTH+1+j+WIDTH-1=3*WIDTH+j时刻输入完成，所以对应接受到E[j][k]的时刻都需要输入C[j][k]
并且C的输入也是对于一行，从开始输入历时WIDTH时长后，等待一个周期，再输入下一组对应位置的数据

写如output_buffer的逻辑，你对应调整

你需要全面分析，考虑如何实现这个控制，可能设计多个模块的修改

    //A [m * k]   B[k * n]   E\C\D[m * n] 
    //! sys_enable_rows: 'K' 维度的掩码 (启用 PE 行 i)
    //! sys_enable_cols: 'N' 维度的掩码 (启用 PE 列 j)

我发现了我一个最开始的设计错误
如果PE[i][j]将存储B[i][j]（weight)，即输入B[W-1][j]到B[0][j]进入PE[0][j]，同时读取变成每个周期读取B的一行，经过一个skew后，倾斜输入，即对于B[k][j]将比B[k][0]晚j个周期输入PE[0][j]
对于输入A[0][i]到A[W-1][i]进入PE[i][0]（input)，同时读取变成每个周期读取A的一行，经过一个skew后，倾斜输入，即对于A[k][j]将比A[k][0]晚j个周期输入PE[j][0]
这样PE[W-1][j]的输出将是E[0][j]到E[W-1][j]（A[k][0]B[0][j]+...+A[k][W-1]B[W-1][j]=E[k][j]）

那么输入C[0][j]到A[W-1][j]进入vpu_sys_data_in[j]，即每个周期读取C的一行，经过一个skew后，倾斜输入，即对于C[k][j]将比C[k][0]晚j个周期输入vpu_sys_data_in[j]
最后输出的D经过一个de-skew，也将每个周期写回D的一行

请你仔细注意，我读取一行，但是这一行是分散到不同的PE上的
例如读取B[W-1]这一行，t=0 B[W-1][0]输入PE[0][0]，而B[W-1][j]将在t=j时刻完全流过skew进入PE[0][j]

这样就不需要要求ABC为列优先存储，也不需要输出D到外部时再进行转置

请你不要怀疑我的数学推导，按照我的要求思考
你需要仔细查看需要修改哪些模块，并合理命名需要修改的地方



我正在设计一个tensor core，在vscode中使用verilog语言，用iverilog进行测试，接下来协助我完成设计和验证

1.数据类型是输入int8，输出int32，有符号

2.核心维度是32*32或64*64，但是我想先设计一个16*16的

3.目标架构是脉冲阵列

4.所有的输入输出矩阵都按照行优先的模式

5.该tensor core只需要用来计算矩阵A*B+C=D，A*B的过程在systolic里完成，+C的过程使用VPU完成


t=0时刻开始第一个B的输入
t=W-1时刻第一个B的输入完成
t=W时刻会输入switch
t=W+1时刻开始第一个A的输入，开始第二个B的输入
t=2W时刻第一个A的输入完成，第二个B的输入完成
t=2*W+1时刻会输入switch，开始第一个C的输入，
t=2*W+2时刻开始第二个A的输入，开始第三个B的输入，第一个D开始输出

1.目前的设计能实现上面这个逻辑吗
2.我想知道发出B的开始输入这个信号是t=-1这个时刻吗，然后t=0时刻数据才能进入systolic中对吗





1.Host写入是按照正常顺序，需要选择 选项 A（硬件处理）

2.我的最终目标是设计重叠流水，即满足以下要求
t=0 ~ W-1：（共W个周期）加载B1
t=W：SWITCH
t=W+1 ~ 2W：（共W个周期）加载A1，同时加载B2
t=2W+1：SWITCH
t=2W+1 ~ 3W：（共W个周期）加载C1
t=2W+2 VPU开始输出D1
......
关于这里的设计我目前的思路是，在接受到计算指令后，对于ABCD的各个任务进行不断的循环，在确定第一次开始时间后，执行W周期，停止1周期，然后再执行W周期，停止1周期...进行循环
switch则是执行1周期，停止W周期，执行1周期...
对于各个任务开始的时间，记加载B1是t=0，考虑信号传输，control unit需要t=-1向input_buffer发出信号
t=W开始发出swich
t=W+1开始加载A1，t=W向input_buffer发出信号
t=2W+1开始加载C1，t=2W向input_buffer发出信号
t=2W+1 D1开始输出
只要确定了第一次开始时间，后续按照循环执行即可

3.需要在 tpu_core 的 C-Skew 路径中把 valid 信号加回来，只有systolic输出valid，vpu才会输出正确的D和valid信号

4.AXI slave和master以及AXL lite都需要撰写，目前先完成tpu_core和control_unit的编写，然后再编写相关模块

5.M K N均< W

先于我进行二次确定，再开始编写相关代码








pe.sv
1. 主要潜在问题：权重的脉动加载逻辑
您的 PE 具有来自北向的 pe_weight_in 和南向的 pe_weight_out 。这强烈暗示了权重是脉动式（systolic）加载的，即权重数据像波浪一样逐个周期地从一个 PE 传递到下一个 PE。

然而，当前的逻辑与此模式不符：

代码段

// 1. 在背景中加载 "影子" 寄存器
if (pe_accept_w_in) begin
    weight_reg_inactive <= pe_weight_in;  
    pe_weight_out       <= pe_weight_in;  
end else begin
    pe_weight_out <= 8'b0;                 
end
问题在于：

当 pe_accept_w_in 为低时，pe_weight_out 被强制清零 。

这会中断权重的脉动流。如果一个权重值需要 5 个周期才能到达第 5 个 PE，那么在这个路径上的所有 PE 的 pe_accept_w_in 都必须保持高电平，这不符合脉动加载的初衷。

典型的脉动加载模式应该是：

数据传递： 权重输入应始终被寄存并传递到下一个 PE。

pe_weight_out <= pe_weight_in; (这行代码应该在 always_ff 块中，并且无条件执行，或者至少不依赖于 pe_accept_w_in)。

加载控制： pe_accept_w_in 信号本身也应该脉动式传递。您需要一个 pe_accept_w_out 端口。

pe_accept_w_out <= pe_accept_w_in;

本地加载： 仅当 pe_accept_w_in 对 当前 PE 有效时，才加载 weight_reg_inactive。


if (pe_accept_w_in) begin weight_reg_inactive <= pe_weight_in; end 

结论： 您当前的权重加载逻辑更像是一种“广播加载”（pe_accept_w_in 同时控制所有 PE）和“脉动输出”的混合体，但 else 分支  会破坏数据的传递。您可能需要重新审视权重加载策略。





2. 关键设计选择：sys_switch_in 的连接方式
这是您需要重点关注的地方。


您的实现： 您将 sys_switch_in[i] 信号连接到每行最左侧的 PE (j == 0) 。然后，pe_switch_out 被连接到右侧 PE 的 pe_switch_in 。





这意味着什么： 这实现了一个**“脉动式”或“偏斜波前” (Skewed Wavefront) 的开关**。当您的控制器在 sys_switch_in 上发送一个脉冲时：

Cycle 0: PE(i, 0) 收到 switch=1 并切换其权重。

Cycle 1: PE(i, 1) 收到来自 PE(i, 0) 的 switch=1 并切换其权重。

Cycle 2: PE(i, 2) 收到来自 PE(i, 1) 的 switch=1 并切换其权重。

...以此类推。

替代方案（更常见）： 许多设计会选择广播 (Broadcast) 开关信号，使一行中的所有 PE 同时 切换。这可以这样实现：

代码段

// 在 generate 循环中:
.pe_switch_in( sys_switch_in[i] ), // <-- 注意：不再有 (j==0) ?
...
.pe_switch_out( /* 不连接 */ ),

结论： 您的代码没有错。它与 pe.sv （它确实有 pe_switch_out ）是兼容的。但这确实意味着，您的“控制器”在发出 sys_switch_in 脉冲后，必须等待 N 个周期（N = 阵列宽度），以确保阵列最右侧的 PE  也完成了权重切换，然后才能开始输入数据。